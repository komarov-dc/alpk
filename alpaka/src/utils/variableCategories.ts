/**
 * Unified Variable Categorization System
 * Used by both VariableHighlightedText and Variable Manager
 */

import type { GlobalVariable } from '@/store/slices/variablesSlice';
import type { Node, Edge } from '@xyflow/react';
import type { ExecutionResult } from '@/types/nodeTypes';

// Variable categories enum
export enum VariableCategory {
  GLOBAL_IMPORTED = 'global_imported',
  GLOBAL_CREATED = 'global_created',
  WORKFLOW_COMPLETED = 'workflow_completed', 
  WORKFLOW_PENDING = 'workflow_pending',
  TRANSITIVE = 'transitive',
  MISSING = 'missing'
}

// Variable source for display purposes
export enum VariableSource {
  GLOBAL = 'global',
  WORKFLOW = 'workflow',
  PENDING = 'pending',
  TRANSITIVE = 'transitive',
  MISSING = 'missing'
}

// Color scheme for variable categories
export const VARIABLE_COLORS = {
  [VariableSource.GLOBAL]: {
    bg: 'bg-purple-500/20',
    text: 'text-purple-400',
    icon: 'ðŸ“¦'
  },
  [VariableSource.WORKFLOW]: {
    bg: 'bg-green-500/20', 
    text: 'text-green-400',
    icon: 'âœ…'
  },
  [VariableSource.PENDING]: {
    bg: 'bg-cyan-500/20',
    text: 'text-cyan-400',
    icon: 'â³'
  },
  [VariableSource.TRANSITIVE]: {
    bg: 'bg-gradient-to-r from-purple-500/20 to-cyan-500/20',
    text: 'bg-gradient-to-r from-purple-400 to-cyan-400 bg-clip-text text-transparent',
    icon: 'ðŸ”—'
  },
  [VariableSource.MISSING]: {
    bg: 'bg-red-500/20',
    text: 'text-red-400',
    icon: 'âš ï¸'
  }
} as const;

// Type-based color and icon (for data type indicators)
export const getTypeIndicator = (type?: string) => {
  switch(type) {
    case 'number': return { color: 'text-blue-400', icon: '#', bg: 'bg-blue-500/20' };
    case 'boolean': return { color: 'text-green-400', icon: 'âœ“', bg: 'bg-green-500/20' };
    case 'json': return { color: 'text-purple-400', icon: '{}', bg: 'bg-purple-500/20' };
    case 'array': return { color: 'text-orange-400', icon: '[]', bg: 'bg-orange-500/20' };
    default: return { color: 'text-gray-400', icon: 'Aa', bg: 'bg-gray-500/20' };
  }
};

interface CategorizeContext {
  globalVariables: Record<string, GlobalVariable>;
  executionResults: Record<string, ExecutionResult>;
  nodes: Node[];
  edges: Edge[];
  currentNodeId?: string;
}

/**
 * Check if a variable is imported (from files)
 */
export function isImportedVariable(variable: GlobalVariable): boolean {
  return variable.description?.includes('Imported from') || false;
}

/**
 * Check if a variable is from workflow/session execution
 */
export function isWorkflowVariable(key: string, variable: GlobalVariable): boolean {
  return key.startsWith('workflow:') || 
         (variable.description?.includes('From LLM Chain:') || false) ||
         (variable.description?.includes('Generated by node execution') || false) ||
         (variable.description?.includes('Workflow variable from') || false);
}

/**
 * Get pending variables for a node (nodes connected by edges but not executed)
 */
export function getPendingVariables(
  nodeId: string,
  edges: Edge[],
  nodes: Node[],
  executionResults: Record<string, ExecutionResult>
): Set<string> {
  const pending = new Set<string>();
  
  // Find all edges where current node is the target
  const incomingEdges = edges.filter(e => e.target === nodeId);
  
  incomingEdges.forEach(edge => {
    const sourceNode = nodes.find(n => n.id === edge.source);
    if (sourceNode) {
      const nodeName = (sourceNode.data?.label as string) || 
                      (sourceNode.type as string) || 
                      `Node_${sourceNode.id.slice(-4)}`;
      
      // Check if we DON'T have execution results for this node
      const hasResults = executionResults[sourceNode.id]?.success;
      
      if (!hasResults) {
        pending.add(nodeName);
      }
    }
  });
  
  return pending;
}

/**
 * Check if a node is reachable upstream through edges
 */
export function isReachableUpstream(
  currentNodeId: string,
  targetNodeName: string,
  nodes: Node[],
  edges: Edge[]
): boolean {
  // Find target node by name
  const targetNode = nodes.find(n => {
    const nodeName = (n.data?.label as string) || 
                    (n.type as string) || 
                    `Node_${n.id.slice(-4)}`;
    return nodeName === targetNodeName;
  });
  
  if (!targetNode) return false;
  
  // BFS upstream from current node
  const visited = new Set<string>();
  const queue = [currentNodeId];
  
  while (queue.length > 0) {
    const current = queue.shift()!;
    
    if (current === targetNode.id) {
      return true;
    }
    
    if (!visited.has(current)) {
      visited.add(current);
      // Add all upstream nodes
      edges.filter(e => e.target === current)
        .forEach(e => queue.push(e.source));
    }
  }
  
  return false;
}

/**
 * Find missing variables referenced in nodes
 */
export function findMissingVariables(
  nodes: Node[],
  globalVariables: Record<string, GlobalVariable>
): Map<string, string[]> {
  const missingVars = new Map<string, string[]>(); // variable name -> nodes that reference it
  const existingVarNames = new Set(Object.keys(globalVariables));
  
  nodes.forEach(node => {
    // Check the same fields that VariableHighlightedText checks
    const textFields: (string | undefined)[] = [
      node.data?.prompt as string | undefined,
      node.data?.system as string | undefined,
      node.data?.template as string | undefined,
      node.data?.value as string | undefined,
      node.data?.code as string | undefined,
      node.data?.content as string | undefined,
      node.data?.text as string | undefined,
      node.data?.message as string | undefined,
      node.data?.query as string | undefined,
      // Also check messages for LLM nodes
      ...(Array.isArray(node.data?.messages) 
        ? (node.data.messages as Array<{content?: string}>).map(m => m.content)
        : [])
    ];
    
    textFields.forEach(field => {
      if (typeof field === 'string' && field.includes('{{')) {
        // Find all {{variable}} references
        const matches = field.matchAll(/\{\{([^}]+)\}\}/g);
        for (const match of matches) {
          if (!match[1]) continue;
          const varName = match[1].trim();
          
          // Check if variable exists (including workflow: prefix)
          const hasValue = existingVarNames.has(varName) || 
                         existingVarNames.has(`workflow:${varName}`);
          
          if (!hasValue) {
            // Check if it's a node name (would be pending or transitive)
            const isNodeName = nodes.some(n => 
              (n.data?.label === varName || n.id === varName)
            );
            
            // Only add to missing if it's not a node name and doesn't exist
            if (!isNodeName) {
              const referencingNodes = missingVars.get(varName) || [];
              referencingNodes.push(node.data?.label as string || node.id);
              missingVars.set(varName, referencingNodes);
            }
          }
        }
      }
    });
  });
  
  return missingVars;
}

/**
 * Main categorization function
 */
export function categorizeVariable(
  varName: string,
  context: CategorizeContext
): {
  category: VariableCategory;
  source: VariableSource;
  value?: string;
  exists: boolean;
} {
  const { globalVariables, executionResults, nodes, edges, currentNodeId } = context;
  
  // Check if it's a pending variable (for current node context)
  if (currentNodeId) {
    const pendingVars = getPendingVariables(currentNodeId, edges, nodes, executionResults);
    if (pendingVars.has(varName)) {
      return {
        category: VariableCategory.WORKFLOW_PENDING,
        source: VariableSource.PENDING,
        exists: false
      };
    }
  }
  
  // Check workflow: prefixed variables
  const workflowVar = globalVariables[`workflow:${varName}`];
  if (workflowVar) {
    return {
      category: VariableCategory.WORKFLOW_COMPLETED,
      source: VariableSource.WORKFLOW,
      value: workflowVar.value,
      exists: true
    };
  }
  
  // Check regular global variables
  const globalVar = globalVariables[varName];
  if (globalVar) {
    const isImported = isImportedVariable(globalVar);
    const isWorkflow = isWorkflowVariable(varName, globalVar);
    
    if (isWorkflow) {
      return {
        category: VariableCategory.WORKFLOW_COMPLETED,
        source: VariableSource.WORKFLOW,
        value: globalVar.value,
        exists: true
      };
    }
    
    return {
      category: isImported ? VariableCategory.GLOBAL_IMPORTED : VariableCategory.GLOBAL_CREATED,
      source: VariableSource.GLOBAL,
      value: globalVar.value,
      exists: true
    };
  }
  
  // Check execution results (completed nodes)
  for (const [nodeId, result] of Object.entries(executionResults)) {
    if (result?.success && result.output) {
      const node = nodes.find(n => n.id === nodeId);
      const nodeLabel = (node?.data?.label as string) || (node?.type as string) || `Node_${nodeId.slice(-4)}`;
      
      if (nodeLabel === varName) {
        const output = result.output as Record<string, unknown>;
        return {
          category: VariableCategory.WORKFLOW_COMPLETED,
          source: VariableSource.WORKFLOW,
          value: JSON.stringify(output.value || output.text || output.response || output),
          exists: true
        };
      }
    }
  }
  
  // Check if transitive (reachable through chain)
  if (currentNodeId && isReachableUpstream(currentNodeId, varName, nodes, edges)) {
    return {
      category: VariableCategory.TRANSITIVE,
      source: VariableSource.TRANSITIVE,
      exists: false
    };
  }
  
  // Variable is missing
  return {
    category: VariableCategory.MISSING,
    source: VariableSource.MISSING,
    exists: false
  };
}