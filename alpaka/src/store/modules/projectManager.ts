import { Node, Edge } from '@xyflow/react';
import { logger } from '@/utils/logger';
import { historyManager } from './historyManager';
import { projectMigration, ProjectMigrationError } from '@/utils/projectMigration';
import { ProjectDataV3 } from '@/utils/projectMigration';
import { ensureCorrectNodeOrder } from '@/utils/nodeOrdering';
import type { ExecutionResult } from '@/types/nodeTypes';

export interface Project {
  id: string;
  name: string;
  description?: string;
}

export interface ProjectState {
  currentProject?: Project;
}

export interface ProjectActions {
  createProject: (name: string, description?: string) => void;
  saveProject: (
    currentProject: Project | undefined,
    nodes: Node[],
    edges: Edge[],
    globalVariables: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>,
    executionResults?: Record<string, ExecutionResult>,
    viewport?: { x: number; y: number; zoom: number } | null
  ) => Promise<void>;
  loadProject: (
    projectId: string,
    setNodes: (nodes: Node[]) => void,
    setEdges: (edges: Edge[]) => void,
    setGlobalVariables: (vars: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>) => void,
    setCurrentProject: (project: Project) => void,
    setExecutionResults?: (results: Record<string, ExecutionResult>) => void,
    executeNode?: (nodeId: string) => Promise<void>,
    setViewport?: (viewport: { x: number; y: number; zoom: number } | null) => void
  ) => Promise<void>;
  updateProjectName: (name: string, setCurrentProject: (project: Project | undefined) => void, currentProject: Project | undefined) => Promise<void>;
  createNewProject: (
    setNodes: (nodes: Node[]) => void,
    setEdges: (edges: Edge[]) => void,
    setGlobalVariables: (vars: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>) => void,
    setCurrentProject: (project: Project | undefined) => void,
    clearExecutionResults: () => void
  ) => Promise<void>;
}

// Project management functions
export const projectActions: ProjectActions = {
  createProject: (/* name: string, description?: string */) => {
    // This will be implemented when we refactor the store
  },

  saveProject: async (
    currentProject: Project | undefined,
    nodes: Node[],
    edges: Edge[],
    globalVariables: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>,
    executionResults?: Record<string, ExecutionResult>,
    viewport?: { x: number; y: number; zoom: number } | null
  ) => {
    if (!currentProject) return;
    
    // Clean nodes before saving - remove transient execution states for persistence
    // Create a deep copy for saving without modifying the runtime state
    // CRITICAL: Preserve parent-child relationships!
    const cleanedNodes = nodes.map(node => {
      // Preserve all node properties including parentId, extent, expandParent
      const cleanedNode = {
        ...node,
        // Explicitly preserve parent-child properties
        parentId: node.parentId,
        extent: node.extent,
        expandParent: node.expandParent,
        data: {
          ...node.data,
          // Remove ONLY transient states from saved data
          isExecuting: false,
          lastExecuted: undefined,
          executionStats: undefined,
          error: undefined
        }
      };
      return cleanedNode;
    });
    
    // Filter out workflow variables if there are no execution results
    // This ensures workflow variables don't persist after Clear All
    const filteredGlobalVariables: typeof globalVariables = {};
    const hasExecutionResults = executionResults && Object.keys(executionResults).length > 0;
    
    Object.entries(globalVariables).forEach(([key, value]) => {
      const isWorkflowVariable = key.startsWith('workflow:') || 
        (value.description?.includes('From LLM Chain:') ||
         value.description?.includes('Generated by node execution') ||
         value.description?.includes('Workflow variable from'));
      
      // Only include non-workflow variables, or workflow variables if there are execution results
      if (!isWorkflowVariable || hasExecutionResults) {
        filteredGlobalVariables[key] = value;
      } else {
        logger.info(`Excluding workflow variable ${key} from save as no execution results exist`);
      }
    });
    
    try {
      let response;
      
      // Try to update project, if it fails - create new one
      response = await fetch(`/api/projects/${currentProject.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: currentProject.name,
          description: currentProject.description,
          nodes: cleanedNodes,
          edges,
          executionResults, // Include execution results in canvasData
          globalVariables: filteredGlobalVariables,
          viewport,
        }),
      });

      if (!response.ok) {
        // If update fails, try to create new project
        response = await fetch('/api/projects', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: currentProject.name,
            description: currentProject.description,
            nodes: cleanedNodes,
            edges,
            executionResults, // Include execution results in fallback creation too
            globalVariables: filteredGlobalVariables,
            viewport,
          }),
        });
      }

      if (!response.ok) {
        throw new Error(`Failed to save project: ${response.statusText}`);
      }

      const savedProject = await response.json();
      logger.info('Project saved successfully:', savedProject.name);
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      logger.error('Failed to save project:', errorObj);
      throw errorObj;
    }
  },

  loadProject: async (
    projectId: string,
    setNodes: (nodes: Node[]) => void,
    setEdges: (edges: Edge[]) => void,
    setGlobalVariables: (vars: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>) => void,
    setCurrentProject: (project: Project) => void,
    setExecutionResults?: (results: Record<string, ExecutionResult>) => void,
    executeNode?: (nodeId: string) => Promise<void>,
    setViewport?: (viewport: { x: number; y: number; zoom: number } | null) => void
  ) => {
    try {
      // Reset execution queue when switching projects
      const { queueManager } = await import('./execution/queueManager');
      queueManager.reset();
      const response = await fetch(`/api/projects/${projectId}`);
      if (!response.ok) {
        throw new Error(`Failed to load project: ${response.statusText}`);
      }
      
      const projectResponse = await response.json();
      
      // Extract canvas data and attempt migration if needed
      let canvasData = projectResponse.project?.canvasData || {};
      
      // Check if migration is needed
      try {
        const version = projectMigration.detectVersion(canvasData);
        logger.info(`Loading project with version: ${version}`);
        
        // Migrate if not current version
        if (version !== projectMigration.currentVersion) {
          logger.info('Project needs migration, upgrading to current version');
          const migrated = projectMigration.migrate(canvasData);
          
          if (projectMigration.validate(migrated)) {
            canvasData = migrated;
            logger.info('Project successfully migrated to current version');
            
            // TODO: Save migrated version back to database
            // This would prevent repeated migrations
          } else {
            logger.warn('Migration validation failed, attempting repair');
            const repaired = projectMigration.repair(canvasData);
            if (repaired) {
              canvasData = repaired;
              logger.info('Project data repaired successfully');
            } else {
              throw new Error('Failed to repair corrupted project data');
            }
          }
        }
      } catch (migrationError) {
        if (migrationError instanceof ProjectMigrationError) {
          logger.error('Migration failed:', migrationError);
          
          // Attempt to repair
          const repaired = projectMigration.repair(canvasData);
          if (repaired) {
            canvasData = repaired;
            logger.info('Project data recovered after migration failure');
          } else {
            // Create a minimal valid project
            canvasData = {
              version: '3.0.0',
              name: projectResponse.project?.name || 'Recovered Project',
              description: 'Project recovered from corrupted data',
              nodes: [],
              edges: [],
              globalVariables: {},
              executionResults: {}
            } as ProjectDataV3;
            logger.warn('Created minimal project structure due to corruption');
          }
        } else {
          throw migrationError;
        }
      }
      
      const rawNodes = canvasData.nodes || [];
      
      // Clean nodes on load - remove any persisted execution states and queue statuses
      // CRITICAL: Preserve parent-child relationships from saved data!
      const nodes = rawNodes.map((node: Node) => ({
        ...node,
        // Explicitly preserve parent-child properties from saved data
        parentId: node.parentId,
        extent: node.extent,
        expandParent: node.expandParent,
        data: {
          ...node.data,
          // Remove ONLY transient states
          isExecuting: false,
          lastExecuted: undefined,
          executionStats: undefined,
          error: undefined,
          queueStatus: undefined // Reset queue status
        }
      }));
      
      // Load project data first
      // CRITICAL: Ensure correct parent-child ordering when loading project
      const orderedNodes = ensureCorrectNodeOrder(nodes);

      const updatedEdges = canvasData.edges || [];
      
      setNodes(orderedNodes);
      setEdges(updatedEdges);
      
      // Set viewport if available and function provided
      if (setViewport && canvasData.viewport) {
        setViewport(canvasData.viewport);
      }
      
      // Global variables come from either the migrated canvasData or the project data
      const rawGlobalVariables = canvasData.globalVariables || projectResponse.project?.globalVariables || {};
      
      // Variables should already be normalized by migration, but ensure consistency
      const normalizedVariables: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }> = {};
      
      Object.entries(rawGlobalVariables).forEach(([key, value]) => {
        // Skip workflow variables if there are no execution results
        // This prevents workflow variables from persisting after Clear All
        const isWorkflowVariable = key.startsWith('workflow:') || 
          (value && typeof value === 'object' && 'description' in value && (
            (value.description as string)?.includes('From LLM Chain:') ||
            (value.description as string)?.includes('Generated by node execution') ||
            (value.description as string)?.includes('Workflow variable from')
          ));
        
        // If it's a workflow variable and we have no execution results, skip it
        if (isWorkflowVariable && (!executionResults || Object.keys(executionResults).length === 0)) {
          logger.info(`Skipping workflow variable ${key} as no execution results exist`);
          return;
        }
        
        if (typeof value === 'string') {
          // Legacy format that wasn't caught by migration
          normalizedVariables[key] = {
            name: key,
            value: value,
            description: 'Loaded from project',
            folder: undefined,
            type: 'string'
          };
        } else if (value && typeof value === 'object' && 'value' in value) {
          // Properly structured variable - ensure all fields are present
          const varObj = value as { name?: string; value: string; description?: string; folder?: string | null; type?: string };
          normalizedVariables[key] = {
            name: varObj.name || key,
            value: varObj.value,
            description: varObj.description,
            folder: varObj.folder !== null ? varObj.folder : undefined,
            type: varObj.type
          };
        } else {
          // Unknown format, log but don't fail
          logger.warn(`Skipping invalid variable format for key ${key}:`, JSON.stringify(value));
        }
      });
      
      setGlobalVariables(normalizedVariables);
      
      // Load execution results if available and function provided
      const executionResults = canvasData.executionResults || {};
      
      if (setExecutionResults && Object.keys(executionResults).length > 0) {
        setExecutionResults(executionResults as Record<string, ExecutionResult>);
      }
      
      // Auto-execute InputNodes with values to restore variables
      
      if (executeNode) {
        const inputNodesToExecute = nodes.filter((node: Node) => 
          node.type === 'input' && 
          node.data?.value && 
          typeof node.data.value === 'string' &&
          node.data.value.trim() !== ''
        );
        
        
        // Execute all InputNodes with values
        for (const inputNode of inputNodesToExecute) {
          try {
            await executeNode(inputNode.id);
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            logger.warn(`Failed to restore variable for InputNode ${inputNode.id}:`, errorMsg);
          }
        }
        
        
        // After auto-execution, we need to convert execution results to global variables
        // This will be handled by the calling code that has access to executionResults
      } else {
        logger.warn('executeNode function not provided to loadProject');
      }
      
      // Clear history and save initial state after loading
      historyManager.clearHistory();
      historyManager.saveToHistory({
        nodes: orderedNodes, // Use properly ordered and cleaned nodes
        edges: canvasData.edges || [],
        selectedNodes: []
      });
      setCurrentProject({
        id: projectResponse.project.id,
        name: projectResponse.project.name,
        description: projectResponse.project.description
      });
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      logger.error('Error loading project:', errorObj);
      
      // Provide better error messages
      if (errorObj.message.includes('Failed to load project')) {
        throw new Error('Could not load project. It may have been deleted or you may not have permission to access it.');
      } else if (errorObj.message.includes('corrupted')) {
        throw new Error('Project data appears to be corrupted. Some data may have been recovered.');
      } else {
        throw errorObj;
      }
    }
  },

  updateProjectName: async (name: string, setCurrentProject: (project: Project | undefined) => void, currentProject: Project | undefined) => {
    if (currentProject) {
      const updatedProject = {
        ...currentProject,
        name
      };
      setCurrentProject(updatedProject);
      
      // Also update in database
      try {
        const response = await fetch(`/api/projects/${currentProject.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name,
            description: currentProject.description || '',
            canvasData: {}, // We'll get this from the current state
          }),
        });
        
        if (!response.ok) {
          logger.error('Failed to update project name in database');
        }
      } catch (error) {
        const errorObj = error instanceof Error ? error : new Error(String(error));
        logger.error('Error updating project name:', errorObj);
      }
    }
  },

  createNewProject: async (
    setNodes: (nodes: Node[]) => void,
    setEdges: (edges: Edge[]) => void,
    setGlobalVariables: (vars: Record<string, { name: string; value: string; description?: string; folder?: string; type?: string }>) => void,
    setCurrentProject: (project: Project | undefined) => void,
    clearExecutionResults: () => void
  ) => {
    try {
      // Reset execution queue when creating new project
      const { queueManager } = await import('./execution/queueManager');
      queueManager.reset();
      // Create new project in database
      const response = await fetch('/api/projects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: 'New Project',
          description: 'Your AI workflow project',
        }),
      });
      
      const data = await response.json();
      if (data.success) {
        // Clear current state first
        setNodes([]);
        setEdges([]);
        setGlobalVariables({});
        clearExecutionResults();
        
        // Clear history and save initial empty state
        historyManager.clearHistory();
        historyManager.saveToHistory({
          nodes: [],
          edges: [],
          selectedNodes: []
        });
        
        // Set the new project as current
        setCurrentProject({
          id: data.project.id,
          name: data.project.name,
          description: data.project.description
        });
      }
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      logger.error('Failed to create new project:', errorObj);
      // Fallback to old behavior
      setNodes([]);
      setEdges([]);
      setGlobalVariables({});
      setCurrentProject(undefined);
      clearExecutionResults();
    }
  }
};
